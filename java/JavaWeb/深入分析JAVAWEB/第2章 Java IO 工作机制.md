## 2 Java I/O 工作机制 ##
I/O是整个人机交互的核心问题，且I/O问题尤其突出，很容易成为一个性能瓶颈
### 2.1 I/O 分类： ###
* 字节操作：InputStream 和 OutputStream
* 字符操作：Writer 和 Reader
* 磁盘操作：File
* 网络操作：Socket
* **数据持久化或网络传输都是以字节进行的，所以必须要有从字符到字节或从字节到字符的转化**
	* 转化过程要经过编解码，不久耗时，而且经常出现乱码问题，很头疼
	* InputStreamReader是从字节到字符，如果不指定编码，则使用默认编码
	* 其中StreamDecoder和StreamEncoder完成编解码过程
### 2.2 I/O 核心问题 ###
* 数据格式影响I/O操作
* 传输方式影响I/O操作
* 也就是将什么样的数据，写到什么地方

### 2.3 磁盘I/O工作机制 ###
* 读取和写入文件I/O操作，都要调用操作系统提供的接口，因为磁盘设备是有操作系统管理的
* 读写分别对应read(),write()两个系统调用
* 只要是系统调用就可能存在内核空间地址和用户空间地址切换的问题
* 这样就会存在，数据从磁盘复制到内核空间，再从内核空间复制到用户空间，会非常缓慢
* 操作系统为了加速I/O访问，在内核空间使用缓存机制

#### 2.3.1 标准访问文件方式 ####
* 读取操作
	* 先看内核缓存中有没有，如果有直接返回
	* 没有就去磁盘中读取，然后缓存在内核中
* 写入操作
	* 将数据从用户地址空间**复制到内核缓存中**，这是写操作已经完成，至于什么时候写到磁盘中有操作系统决定，除非显示调用了sync同步命令

#### 2.3.2 直接I/O方式 ####
* 应用程序直接访问磁盘数据，不经过操作系统内核缓冲，目的是减少一次数据复制
* 如数据库，可以自己管理缓存热点数据，而操作系统很难做到缓存特定的数据
* 通常直接I/O和异步I/O结合使用

#### 2.3.3 同步访问文件方式 ####
* 数据的读取、写入同时同步操作
* 只有当数据被成功写入磁盘后，才返回给应用程序成功的标志
* 性能比较差，一般用于数据安全性很高的场景

#### 2.3.4 异步访问方式 ####
* 当线程发送数据请求后，会直接去执行其他事务，而不是阻塞等待

#### 2.3.5 内存映射方式 ####
* 即内核缓存和磁盘数据时共享的
* 也是为了减少数据复制

### 2.4 Java 访问磁盘文件 ###
* 通过FileInputStream来访问文件
* 其中有StreamDecoder来完成字节到字符的转化

### 2.5 Java 序列化技术 ###
* 当父类继承Serializable接口时，所有子类都可以被序列化
* 子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，但数据丢失），子类中的属性仍能正确序列化
* 如果序列化的属性是对象，则这个对象也必须实现Serializable接口，否则会报错
* 在反序列化时，如果对象的属性有修改和删减，则修改部分属性会丢失，但不会报错
* 在反序列化时，如果serialVersionUID被修改，则反序列化时会失败

### 2.6 网络I/O工作机制 ###
#### 2.6.1 TCP 状态转换 ####
* closed：起始点，在超时或者连接关闭时，进入此状态
* listen：Server 端在等待连接时的状态
* syn-sent：客户端发起连接，发送syn给服务端，如果服务端不能连接，直接进入closed状态
* syn-rcvd：服务端接收到客户端syn请求，状态有listen->syn-rcvd。同时回应一个ack，发送一个syn给客户端；另一种情况，客户端在发起syn的同时接收到了服务端的syn，客户端会有syn-sent，转化为syn-rcvd
* established：服务端和客户端完成3次握手进入后的状态，说明已经可以传输数据了
* time-wait：

#### 2.6.2 影响网络传输的因素 ####
* 网络带宽：即一条物理链路在1s内能够传输的最大比特数（b/s）
* 传输距离：在光纤中因为折射率，速度大概是2/3，如果在杭州和青岛的两个机房同步数据，必定存在30ms的传输延时
* TCP拥塞控制：TCP传输方和接收方用拥塞控制达到步调一致，会设定一个窗口（BDP）

#### 2.6.3 Java Socket 的工作机制 ####
* Socket是一个抽象的概念，可以把它比作两个城市之间的交通工具，有了它，才可以在城市之间来回穿梭
* Socket如交通工具一样，有多种，大部分使用TCP/IP的流套接字，他是一个稳定的通信协议

#### 2.6.4 建立通信链路 ####
* 客户端要与服务端通信是，客户端首先要创建一个Socket实例，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并**创建一个包含本地地址、远端地址和端口号的套接字数据结构**，这个数据结构一直保存在系统中，直到连接关闭
* 之后要 进行TCP的3次握手协议，完成后，Socket才创建完成，否则，抛IOException错误
* 在完成3次握手后，server端会创建一个新的Socket专门和这个客户端连接

#### 2.6.5 数据传输 ####
* 连接建立成功后，客户端和服务端都有一个Socket实例，每个都有一个inputStream和outputStream，并通过这两个对象来交换数据
* 网络I/O是通过字节流传输，会有一定大小的缓存区，数据的写入和读取都是通过这个缓存区完成的
* 写入端将数据写到outputstream对象的sendQ队列中，**当队列填满时，数据将被转移到另一端的inputStream的RecvQ队列中**
* 如果这时，recvQ队列已经满了，则outputStream的write方法会被阻塞，直到RecvQ队列有足够的空间容纳sendQ发送的数据
* 缓存区的大小、写入端/读取端的速度，非常影响连接的数据传输效率
* 如果两边同时传输数据可能会产生死锁，NIO将避免此情况

### 2.7 NIO 工作方式 ###
#### 2.7.1 BIO 带来的挑战 ####
* BIO即阻塞IO，不管是磁盘I/O，还是网络I/O，数据写入和读取时都可能会阻塞

#### 2.7.2 NIO 工作机制 ####
* NIO有三个核心的概念
	* Channel：相比socket更具体，可以把它当作具体的交通工具
	* Buffer：相比Stream更加具体，channel是汽车的话，Buffer就是汽车上的座位
	* Selector：是车辆调度系统，监控每辆车运行状态

* NIO模式用户可以控制很多参数
* 关键是，有一个线程来处理所有连接的数据交互，每个连接的数据交互都不是阻塞方式，所以可以同时处理大量的连接请求

* Buffer是取的Socket缓存区的数据，即RecvQ,SendQ，也可以设置直接取操作系统缓存数据

#### 2.7.3 NIO的数据访问方式 ####
* NIO有两个优化的方法
	* FileChannel.transferXXX
		* 减少数据从内核到用户空间的复制，数据直接在内核空间移动
	* FileChannel.map
		* 内存映射，适合大文件的只读性操作，如大文件的MD5校验

### 2.8 I/O 调优 ###
#### 2.8.1 磁盘I/O优化 ####
* 性能检测
	* 查看系统的I/O wait 是否超过25%，若是，则很可能I/O是一个瓶颈
	* 查看IOPS，比较应用程序需要最低的IOPS和磁盘的IOPS，磁盘IOPS能不能达到要求，可以通过RAID技术提升磁盘IOPS
* 提升I/O性能
	* 增加缓存，较少磁盘访问次数
	* 优化磁盘管理系统
	* 数据设计索引，采用异步和非阻塞方式加快磁盘访问速度
	* 应用合理的RAID策略

#### 2.8.2 TCP 网络参数调优 ####
* 查看可用端口范围，如果偏少时，会遇到大量并发请求在等待建立连接
* 设置更小的timeout时间，快速释放请求

#### 2.8.3 网络 I/O 优化 ####
* 减少网络交互次数
	* 设置缓存，先从缓存中取
	* 合并访问请求
* 减少网络传输数据量的大小
	* 数据压缩
	* 简单通信协议
	* 尽量减少编码：尽量直接以字节的形式发送，提前将字符串转化为字节

#### 2.8.4 应用场景 ####
* 同步阻塞：最常用，I/O性能很差，CPU大部分处于空闲状态
* 同步非阻塞：适用于网络I/O是长连接，同时数据也不是很多的情况，用CPU换I/O
* 异步阻塞：分布式数据库备份，有一份是同步阻塞记录，备份的是异步阻塞
* 异步非阻塞：适用于同时传多分数据到集群中的不同机器上，数据量虽然不大，但是很频繁

---
* 同步：一个任务的完成，需要等到依赖任务完成后，才能完成。发送任务的一方，需要轮询任务完成状况
* 异步：发送一个任务后，**不需要轮询**此任务的状态，而是让任务来通知自己
* 阻塞：发送一个任务后，该线程不能做其他事情，必须等到任务返回，才能继续往下进行
* 非阻塞：发送一个任务后，**可以往下进行**，线程不会被阻塞

