## 适配器模式 ##
**功能**：将一个类的接口(adaptee)转换成客户端能够接受的接口(target)

* Target：目标接口
* Adaptee：需要适配的接口
* Adapter：适配器，将源接口适配成目标接口

* **继承源接口，实现目标接口**

**举例：**   
inputStreamReader：将字节转换成字符  

* 目标接口是 Reader
* 源接口是 inputStream
* 它持有 inputStream 的引用，并实现了Reader接口

**归纳：**  

* 首先客户端给了一个客户端接口，让我按照特定的数据格式给它返回数据
* 但是我现在通过一个现成的服务端接口得到的数据，不符合这个接口的要求
* 我肯定要实现客户端接口，**在实现类中继承或者依赖客户端接口**
	* 在实现客户端接口的方法内，调用客户端接口，得到数据，再对数据进行处理后返回


## 装饰器模式 ##
**功能：** 将某个类装扮一下，使它功能更强大，不改变类结构，对使用者透明

* Component：被装饰对象的抽象类
* ConcreteComponent：component的实现类
* Decorator：装饰器角色，持有一个component对象的引用，并实现了该接口
* concreteDecorator：具体装饰器实现类，**构造器注入一个具体的Component对象，并覆盖Decorator实现的component接口，在实现方法中，调用ConcreteComponent方法，并添加自己的方法**

**举例：**  
BufferedInputStream：将fileInputStream读取的流，保存在内存中  

* inputStream 是 component
* fileInputStream 是 concreteComponent
* FilterInputStream 是 装饰类 
* BufferedInputStream 是 装饰后的类

**归纳：** 

* 我有一个类，但是想在这个类的基础上，添加一些功能
* 在不修改这个类和**对客户端透明**的前提下
	* 我必须重新设计一个它的**兄弟类**，也就是要**实现相同的接口**
	* 并且**依赖基础实现类**，并在装饰类的方法中，调用基础类的方法
	* 并在具体装饰类中，**通过构造器注入基础实现类**，并实现增强方法


## 适配器模式与装饰器模式的区别 ##
* 他俩都有一个别名：包装模式，都起到包装一个类或对象的作用
* 适配器模式：**将服务端接口包装成客户端需要的接口**
* 装饰器模式：**将一个类，包装增强成一个兄弟类**，其中有特定的增强方法
* 一个是实现接口，一个是增强类


## 访问者模式 ##
**功能：**将稳定的数据结构(节点数据不编号)和不断变化的数据访问者（每个访问者对节点的操作不一样）解耦，定义不同的访问者，不会改变数据结构。所以需要在节点中，添加一个accept方法，接收不同的访问者，并将节点自身传给访问者的view方法。这样节点的结构永远不会变，这是在各个访问者中，提取节点的数据，并对数据做不同的处理

* Element：抽象节点元素，提供一个接口，接收不同的访问者对象
* ConcreteElement：具体节点元素，实现节点元素接口，在方法中调用访问者的view方法，并将自身当作参数传给访问者


* Vistor：抽象访问者，声明所有访问者需要的接口，每个接口，对应不同的节点中的数据类型，如：节点中有消费账单、收入账单两种类型，那么就需要声明两个接口
* ConcreteVistor：具体访问者，实现接口，对不同的节点类型做不同的处理


* ObjectStructure：结构对象，提供一个接口，能够访问到所有节点元素
* Client：客户端，分别创建访问者和节点元素的对象，调用访问者访问节点

**举例：**Javac 中的语法分析过程  

* tree：抽象节点元素
* JCIf、JCTry、JCBreak、JCReturn 是不同的节点元素，节点元素种类基本不会变了  
* vistor：抽象的访问者
* TreeScanner、Enter、Attr、Gen 等是具体访问者
* JCCompilationUnit：结构对象，持有整个语法树，即所有元素节点集合
* JavaCompiler：客户端，同时持有节点元素和访问者，操作不同的访问者访问同一语法树
* 点击查看[访问者模式代码][1]例子

**归纳：**  

* 有固定的1个或多个节点元素
* 有不固定的访问者
* 在每个访问者中有多个查看方法view，分别查看不同的节点
* 每个节点中都有一个accept方法接收不同的访问者
* **关键**
	* 在结构对象中，遍历节点对象
	* **将访问者作为参数，传给节点对象**
	* **这样就有两次动态分配过程了！**
		* 第一次，节点是动态决定的，传入的访问者是静态类型
		* 第二次，在accept方法中，访问者的调用时动态类型，节点是静态的了，但是现在的节点的静态类型已经动态分配过滤
	* 如果将节点作为参数，传给访问者，那么只有一次动态分配，因为传入的是节点的静态类型，访问者就不能区分不同类型节点了！

* **最关键的概念是，访问者模式，用来动态多分配的方法，同时区别了不同的节点实例，和不同的访问者实例**

## 门面模式 ##
**功能：**提供一个高层次的接口，将一些复杂的流程封装到此接口中，使得子系统更容易使用  

* Facade：门面角色，客户端可以调用这个角色的方法，该角色将请求委派到相应的子系统中
* subsystem：子系统角色，供门面角色调用，对子系统而言，门面仅仅是一个客户端角色

* 在Tomcat中有很多组件，每个组件要相互交互数据，通过门面可以很好的隔离数据

**举例：**  

* HttpRequestFacade类封装了HttpRequest接口，通过HttpRequestFacade访问到的数据都被代理到HttpRequest中


## 观察者模式 ##
**功能：** 也即发布-订阅模式，也就是事件监听机制，它定义了一种一对多的依赖关系，一个主题，多个观察者，当主题发生变化时，会主动通知观察者，这样观察者便能针对主题发生的变化，执行某些对应的动作

* Observable：抽象主题，定义了管理观察者的添加、删除和通知方法
* Container：具体主题，对观察者进行管理，并在自身发生变化时，通知观察者
* Observer：抽象观察者，定义主题发生变化时，具体观察者必须执行的方法
* ContainerConfig：具体观察者，实现了当主题发生变化时，应该执行的动作

**举例：**Tomcat生命周期管理  

* Lifecycle:相当于抽象主题角色，所有的容器类与组件实现类都实现了这个接口。如StandardContext
* LifecycleListener:相当于抽象观察者角色,具体的实现类有ContextConfig, HostConfig, EngineConfig类，它们在容器启动时与停止时触发
* LifecycleEvent:生命周期事件，对主题与发生的事件进行封装
* LifecycleSupport:生命周期管理的实用类，提供对观察者的添加，删除及通知观察者的方法
* LifecycleException:生命周期异常类
* 
## 图示 ##
### 访问者模式 ###
![访问者模式](https://raw.githubusercontent.com/wangkang09/knowledge-summary/master/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cite/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png )
### 门面模式 ###
![门面模式](https://raw.githubusercontent.com/wangkang09/knowledge-summary/master/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/cite/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.gif)



## 参考文献

[设计模式学习之访问者模式](https://blog.csdn.net/u012124438/article/details/70537203)

[Tomcat生命周期管理与观察者模式](https://www.cnblogs.com/chenying99/archive/2012/09/05/2671199.html) 



[1]:./cite/访问者模式代码.html
