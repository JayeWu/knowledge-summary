## 共享对象的并发读写 ##

### 1. 读写锁 ###
* 读写锁实际是一种特殊的自旋锁
* 它把对共享资源的访问者划分成读者和写者
* 一个读写锁同时只能有一个写者或多个读者（与CPU数相关），但不能同时既有读者又有写者。
* 最大可能的读者数为实际的逻辑CPU数。写者是排他性的
* 在读写锁保持期间也是抢占失效的。
* 如果读写锁当前没有读者，也没有写者，那么写者可以立刻获得读写锁，否则它必须自旋在那里，直到没有任何写者或读者。如果读写锁没有写者，那么读者可以立即获得该读写锁，否则读者必须自旋在那里，直到写者释放该读写锁。

### 2. 引用计数的问题 ###
* 类似Copy on write的方式，每次更新时都构造新的对象
* 在更新过程中，读取操作还是读取旧的对象
* 更新操作完成后，原子的替换掉指针使其指向新的对象
* 而被替换掉的对象**不能立即释放**，而是要确保这个**对象不再被继续使用**的情况下，才能将其释放掉
* 使用**引用计数机制**，在读取前将引用计数加1，读取完毕后将引用计数减1，当引用计数减到0的时候，表示没人在使用这个对象，可以将其释放掉
* 取得全局指针g_conf和通过这个指针操作对象的引用计数这两个操作<font color=red>**并非原子的！**</font>
* 一个线程取得**变量指针**后，引用计数没加1，被切换了，另一个线程操作变量，变更了此变量的指针，但切换到第一个线程时，此线程取得的指针已经失效

### 3. 带锁的引用计数 ###
* 将读写g_conf和修改引用计数两个操作放在一个独立全局锁（g_lock）的临界区执行
* 一方面可能存在读者或写者被饿死的情况
* 另一方面多个写者无法并发
* 应用在copy on write btree等数据结构中时，多个写者相互阻塞的问题会影响到整个数据结构的并发性能
* 有锁引用计数，主要是用了**<font color=red>范围更小读写锁</font>**，更改的时候，别的线程仍然可以更改，**只有替换引用的时候，会阻塞其他线程**，替换引用！
* **<font color=red>通过读写锁，使2的两个操作原子化</font>**


### 4. 无锁的引用计数 ###
* 无论读取g_conf还是替换g_conf都不在锁中进行
* 每次构造新的GConf对象的要同时分配新的RefNode来保存GConf对象的地址
* RefNode对象的分配和释放由专用的分配器进行分配和重用，一旦分配就不会释放回系统，分配器是一个定长的数组，gnode的node_idex就是数组的下标
* **改变的是gnode，用新的gnode覆盖旧的gnode这是原子操作**
* **<font color=red>通过GNODE，使2的两个操作原子化</font>**