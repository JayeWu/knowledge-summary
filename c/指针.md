## 指针 ##
### 定义 ###
* **每一个变量，都有地址和值**，**这是最关键的概念！**  

### 复杂类型说明 ###
> int p; `这是一个普通的整型变量`  
> int *p; `p先与*结合，说明p是一个指针，再与int结合，说明指针指向的类型是int型`  
> int p[3]; `p先与[]结合，说明P是一个数组，再与int结合，说明数组里的元素是int`    
> int *p[3]; `p先与[]结合，说明p是一个数组，再与*结合，说明数组里存放的是指针，再与int结合，说明指针指向的是int`  
> int *p[3]; `p先与[]结合，说明p是一个数组，再与*结合，说明数组里存放的是指针，再与int结合，说明指针指向的是int`  
> int (*p)[3]; `p先与*结合，说明p是一个指针，再与[]结合，说明指向数组，在与int结合，说明数组里是int`
> int **p; `p先与*结合，说明p是一个指针，再与*结合，说明指针指向的指针，再与int结合，说明指针指向的是int`
>
> int p(int); `p先与()结合，说明p是一个函数，再与int结合，说明函数的参数是int，再与int结合，说明函数的返回值是int`
> int (*p)(int); `p先与*结合，说明p是一个指针，在于()结合，说明指向一个函数，再与int结合说明函数的参数是int，再与int结合说明，返回值是int`
> int *(*p(int))[3]; `p先与(int)结合，说明p是参数为int的函数，再与*结合，说明函数的返回值是一个指针，再与[]结合，说明指针指向的是一个数组，再与*结合，说明数组里存放的是指针，再与int结合，说明指针指向的是int`


### 指针之间的减法 ###
* 必须是同一类型的指针
* 返回的是一个long型的值，表示这两个指针中间相差多少个指针指向类型的元素

int a[5] = {1,2,3,4,5};  
int *p = (int *)(&a+1);  
int *P = (int *)(&(a+1));  
&a+1：表示，**先取a的地址，在加上sizeof(a)的值**，即&a + 5*sizeof(int)  
&(a+1)：表示，a的首地址+sizeof(int)，即得到的是a[1]的地址  

---
char a[20]=" You_are_a_boy";  
char *p=a;//char\* 　p=a;  
char **ptr=&p;//关键，给指针Ptr赋值，ptr的值是&p，即p的地址,这样写会更好理解，char\*\* 　ptr=&p;很明显，仅仅是给变量ptr赋值    
printf("\*\*ptr=%c\n",\*\*ptr);//即使a的首地址，首先ptr=&p,所以\*ptr=p,所以\*\*ptr=\*p=a

ptr++;//ptr=ptr+1=&p+1=&p+sizeof(p)=&p+sizeof(char \*)=&p+4  

printf("\*\*ptr=%c\n",\*\*ptr);//ptr=&p=4,\*ptr=\*(&p+4)，<font color=red>**到这里就是一个未知的地址了!**</font>  

\*p+1 等效于 a[0]=a[0]+1;  

\*(\*ptr+1)：

* 其中\*ptr=\*&p=p  
* 所以=\*(p+1)=a+sizeof(p)=a+4=a[4]  

---
### 运算符&和* ###
* **&a 的运算结果是一个指针**
* 指针的类型是a的类型加个\*，如int \*
* 指针指向的地址，就是a的地址

* \*p的结果时p的值，表示的地址的值

---
    int a=12; int b; int *p; int **ptr;
    p=&a; //&a 的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a 的地址。
    *p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是p 所指向的地址，显然，*p 就是变量a。
    ptr=&p; //&p 的结果是个指针，该指针的类型是p 的类型加个*，在这里是int **。该指针所指向的类型是p 的类型，这里是int*。该指针所指向的地址就是指针p 自己的地址。
    *ptr=&b; //*ptr 是个指针，&b 的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以用&b 来给*ptr 赋值就是毫无问题的了。
    **ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果是一个int 类型的变量。

---
sizeof(p)：表示p指针自身类型的大型，而不是别的类型

### 指针和结构类型的关系 ###
---
    struct MyStruct
    {
    	int a;
    	int b;
    	int c;
    };
    struct MyStruct ss={20,30,40};
    //声明了结构对象ss，并把ss 的成员初始化为20，30 和40。
    struct MyStruct *ptr=&ss;
    //声明了一个指向结构对象ss 的指针。它的类型是
    //MyStruct *,它指向的类型是MyStruct。
    int *pstr=(int*)&ss;
    //声明了一个指向结构对象ss 的指针。但是pstr 和

ptr->a,ptr->b,ptr->c;来访问三个变量。也可以这样(*ptr).a,但不建议  

\*pstr;访问a。\*(pstr+1);访问b。\*(pstr+2);访问c。**不能通过这种方式访问，因为结构体有填充字！**


### 指针和函数的关系 ###
---
