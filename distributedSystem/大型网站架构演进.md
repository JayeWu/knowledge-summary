## 什么是大型网站 ##

* 海量的数据
* 访问量特别高，即高并发
* 业务和系统复杂

## 单机网站架构 ##
* 开源的 Server 容器，直接使用JSP/Servlet等技术或一些开源的框架来构建应用。如：Jetty，Tomcat，JBoos,付费的有：Weblogic( Oracle), WebSphere（IBM)
* 选择一个数据库管理系统来存储数据

## 大型网站的核心 ##
* 计算：Apllication Server 完成的业务功能和逻辑，用于计算
* 存储：数据库

## 简单交易网站功能 ##
* 用户
	* 用户注册
	* 用户管理
	* 信息维护
	* ...
	
* 商品
	* 商品展示
	* 商品管理
	* ...

* 交易
	* 创建交易
	* 交易管理
	* ...

这三个功能模块，是在一个 Apllication Server 中，通过 JVM 内部的方法调用来进行交互。  
应用和数据库之间通过 JDBC 进行访问。  

网站架构图，参照《大型网站系统与Java中间件实践》 P40  

## 单机负载告警，数据库与应用分离 ##
通过数据库与应用的分离，这两个应用的资源更多了，暂时缓解了两个应用系统的压力。  
但是，随着访问量继续增大，这两个单机系统还是会产生压力。

## 服务器负载告警，让服务器走向集群 ##
* 应用服务器从一台变成两台，通过两台服务器，对外提供服务，分担压力
* 用户对两个应用服务器访问的选择，通过 DNS 或在集群前增加负载均衡设备解决
* Sessin 问题

### 解决集群后的 Session 问题 ###
#### 什么是 Session ####
* HTTP 是无状态的，通过一个唯一标识，区分请求的是哪个会话
* 在会话开始时，分配一个唯一会话标识（SessionId），通过 Cookie 把这个标识告诉浏览器
* 以后每次请求的时候，浏览器都会带上这个会话标识，来告诉 Web 服务器，请求属于哪个会话
* 在 Web 服务器上，各个会话有独立的存储，保存不同的会话信息
* 如果禁用了 Cookie，可以把这个会话标识放到 URL 的参数中

#### 问题 ####
* 若有多台服务器，同一个用户的多次请求，可能会访问不同的服务器
* 而会话是每个服务器，单独存储的
* 这样，同一个用户的多次请求，在不同服务器上，是不同的会话

#### 方案 ####
1. Session Sticky
	1. 通过对负载均衡器做处理，时同样 Session 的请求每次都发送到同一个服务器端处理
	2. **问题1**：如果有一台 Web 服务器宕机或重启，那么这个会话就会丢失，用户就要重新登录了
	3. **问题2**：会话标识是应用层的信息，如果负载均衡器要将同一个会话的请求都保存到同一个 Web 服务器上，就需要进行应用层的解析，这个开销比第四层的交换要大
	4. **问题3**：负载均衡变为了一个有状态的节点，要将会话保存到具体 Web 服务器的映射。和无状态的节点相比，内存消耗会更大，容灾会更麻烦 
2. Session Replication 
	1. 在 Web 服务器之间增加了会话数据同步，保证了不同服务器之间的 Session 数据的一致
	2. 一般容器都支持次方式
	3. **问题1**：同步增加了网络开销，如果同步数很大，变化很快的话，开销将非常大
	4. **问题2**：每台机器用于保存 Session 数据的内容占用会很严重
3. Session 数据集集中存储
	1. 不同服务器从同样的地方获取 Session
	2. 可以使用数据库或其他分布式存储系统
	3. 相比 Session Replication，网络带宽消耗小
	4. **问题1**：读写 Session 通过网络操作，存在延时和不稳定性
	5. **问题2**：如果存储 Session 的机器或者集群有问题，会影响应用
	6. **优势**：但服务器数量较大，Session 数较多时，优势很明显
4. Cookie Based
	1. 将Session 数据放在 Cookie 中，然后在服务器上从 Cookie 中生成对应的 Session数据
	2. **优势**：不会依赖外部的存储系统，不存在写入 Session 时的网络时延、不稳定性
	3. **问题1**：Cookie 长度限制，会限制 Session 数据的长度
	4. **问题2**：安全性。Session 数据本来都是服务器端数据。可以对 Cookie 中的 Session 数据加密，但是，物理上不能接触才是安全的
	5. **带宽消耗**：每次请求都带上一大串 Cookie
	6. **性能影响**：对于服务器而言，在同样的处理情况下，响应结果输出越少，支持的并发请求就越多

5. 对于大型网站来说，Session Sticky 和 Session 集中存储是比较好的方案

## 数据读压力变大，读写分离 ##
### 增加一个数据库，作为读库 ###
#### 问题 ####
* 数据复制
* 数据源选择：如何做到写操作走主库，读操作走读库

### 搜索引擎其实是一个读库 ###
* 通过使用搜索引擎的倒排表方式，能够大大提升检索速度。  
* 构建搜索引擎的过程，就是一个数据复制的过程，只不过不是简单复制对应的数据。

### 缓存 ###
1. 数据缓存  
	 　　缓存系统通过 Key-Value 键值对，保存热数据，但缓存容量不够时，清楚最近不被访问的数据
2. 页面缓存

避免局部热点，并且缓存服务器扩容或缩容要尽量平滑（使用一致性　Hash）
	

## 弥补关系型数据库的不足，引入分布式存储系统 ##
* 分布式文件系统
* 分布式 Key-Value 系统
* 分布式数据库

## 读写分离后，数据库又遇到瓶颈 ##
### 专库专用，数据库垂直拆分 ###
* 应用需要配置多数据源，每个数据库连接池的隔离
* 处理跨业务事务
	* 使用分布式事务
	* 去掉事务或不追求强事务支持

### 垂直拆分后，数据水平拆分 ###
* 把同一个表的数据，拆到两个数据库中
* 水平拆分解决数据更新瓶颈，垂直拆分解决数据读取瓶颈
* 需要解决SQL路由问题
* 数据表主键问题
* 需从两个数据库中取数据，而且要数据分页时的问题

## 数据库问题解决，应用面对新挑战 ##
### 应用拆分 ###
随着业务的发展，应用的功能会越来越多，应用也会越来越大，维护和扩展越来越难。这就需要应用拆分了。  

* 根据业务的特性把应用拆开 

### 走服务化的路 ###

* 按服务拆分应用
* 服务化需要一些基础组件的支撑

### 初识消息中间件 ###
* 异步
* 解耦