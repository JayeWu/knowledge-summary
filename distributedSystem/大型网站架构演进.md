## 什么是大型网站 ##

* 海量的数据
* 访问量特别高，即高并发
* 业务和系统复杂

## 单机网站架构 ##
* 开源的 Server 容器，直接使用JSP/Servlet等技术或一些开源的框架来构建应用。如：Jetty，Tomcat，JBoos,付费的有：Weblogic( Oracle), WebSphere（IBM)
* 选择一个数据库管理系统来存储数据

## 大型网站的核心 ##
* 计算：Apllication Server 完成的业务功能和逻辑，用于计算
* 存储：数据库

## 简单交易网站功能 ##
* 用户
	* 用户注册
	* 用户管理
	* 信息维护
	* ...
	
* 商品
	* 商品展示
	* 商品管理
	* ...

* 交易
	* 创建交易
	* 交易管理
	* ...

这三个功能模块，是在一个 Apllication Server 中，通过 JVM 内部的方法调用来进行交互。  
应用和数据库之间通过 JDBC 进行访问。  

网站架构图，参照《大型网站系统与Java中间件实践》 P40  

## 单机负载告警，数据库与应用分离 ##
通过数据库与应用的分离，这两个应用的资源更多了，暂时缓解了两个应用系统的压力。  
但是，随着访问量继续增大，这两个单机系统还是会产生压力。

## 服务器负载告警，让服务器走向集群 ##
* 应用服务器从一台变成两台，通过两台服务器，对外提供服务，分担压力
* 用户对两个应用服务器访问的选择，通过 DNS 或在集群前增加负载均衡设备解决
* Sessin 问题

### 解决集群后的 Session 问题 ###
#### 什么是 Session ####
* HTTP 是无状态的，通过一个唯一标识，区分请求的是哪个会话
* 在会话开始时，分配一个唯一会话标识（SessionId），通过 Cookie 把这个标识告诉浏览器
* 以后每次请求的时候，浏览器都会带上这个会话标识，来告诉 Web 服务器，请求属于哪个会话
* 在 Web 服务器上，各个会话有独立的存储，保存不同的会话信息
* 如果禁用了 Cookie，可以把这个会话标识放到 URL 的参数中

#### 问题 ####
* 若有多台服务器，同一个用户的多次请求，可能会访问不同的服务器
* 而会话是每个服务器，单独存储的
* 这样，同一个用户的多次请求，在不同服务器上，是不同的会话

#### 方案 ####
1. Session Sticky
	1. 通过对负载均衡器做处理，时同样 Session 的请求每次都发送到同一个服务器端处理
	2. **问题1**：如果有一台 Web 服务器宕机或重启，那么这个会话就会丢失，用户就要重新登录了
	3. **问题2**：会话标识是应用层的信息，如果负载均衡器要将同一个会话的请求都保存到同一个 Web 服务器上，就需要进行应用层的解析，这个开销比第四层的交换要大
	4. **问题3**：负载均衡变为了一个有状态的节点，要将会话保存到具体 Web 服务器的映射。和无状态的节点相比，内存消耗会更大，容灾会更麻烦 
2. Session Replication 
	1. 在 Web 服务器之间增加了会话数据同步，保证了不同服务器之间的 Session 数据的一致
	2. 一般容器都支持次方式
	3. **问题1**：同步增加了网络开销，如果同步数很大，变化很快的话，开销将非常大
	4. **问题2**：每台机器用于保存 Session 数据的内容占用会很严重
3. Session 数据集集中存储
	1. 不同服务器从同样的地方获取 Session
	2. 可以使用数据库或其他分布式存储系统
	3. 相比 Session Replication，网络带宽消耗小
	4. **问题1**：读写 Session 通过网络操作，存在延时和不稳定性
	5. **问题2**：如果存储 Session 的机器或者集群有问题，会影响应用
	6. **优势**：但服务器数量较大，Session 数较多时，优势很明显
4. Cookie Based
	1. 将Session 数据放在 Cookie 中，然后在服务器上从 Cookie 中生成对应的 Session数据
	2. **优势**：不会依赖外部的存储系统，不存在写入 Session 时的网络时延、不稳定性
	3. **问题1**：Cookie 长度限制，会限制 Session 数据的长度
	4. **问题2**：安全性。Session 数据本来都是服务器端数据。可以对 Cookie 中的 Session 数据加密，但是，物理上不能接触才是安全的
	5. **带宽消耗**：每次请求都带上一大串 Cookie
	6. **性能影响**：对于服务器而言，在同样的处理情况下，响应结果输出越少，支持的并发请求就越多

5. 对于大型网站来说，Session Sticky 和 Session 集中存储是比较好的方案

## 数据读压力变大，读写分离 ##
### 增加一个数据库，作为读库 ###
#### 问题 ####
* 数据复制
* 数据源选择：如何做到写操作走主库，读操作走读库

### 搜索引擎其实是一个读库 ###
* 通过使用搜索引擎的倒排表方式，能够大大提升检索速度。  
* 构建搜索引擎的过程，就是一个数据复制的过程，只不过不是简单复制对应的数据。

### 缓存 ###
1. 数据缓存  
	 　　缓存系统通过 Key-Value 键值对，保存热数据，但缓存容量不够时，清楚最近不被访问的数据
2. 页面缓存

避免局部热点，并且缓存服务器扩容或缩容要尽量平滑（使用一致性　Hash）
	

## 弥补关系型数据库的不足，引入分布式存储系统 ##
* 分布式文件系统
* 分布式 Key-Value 系统
* 分布式数据库

## 读写分离后，数据库又遇到瓶颈 ##
### 专库专用，数据库垂直拆分 ###
* 应用需要配置多数据源，每个数据库连接池的隔离
* 处理跨业务事务
	* 使用分布式事务
	* 去掉事务或不追求强事务支持

### 垂直拆分后，数据水平拆分 ###
* 把同一个表的数据，拆到两个数据库中
* 水平拆分解决数据更新瓶颈，垂直拆分解决数据读取瓶颈
* 需要解决SQL路由问题
* 数据表主键问题
* 需从两个数据库中取数据，而且要数据分页时的问题

## 数据库问题解决，应用面对新挑战 ##
### 应用拆分 ###
随着业务的发展，应用的功能会越来越多，应用也会越来越大，维护和扩展越来越难。这就需要应用拆分了。  

* 根据业务的特性把应用拆开 

### 走服务化的路 ###

* 按服务拆分应用
* 服务化需要一些基础组件的支撑

### 初识消息中间件 ###
* 异步
* 解耦

## 大型网站的存储支持 ##
在大型网站中，基本上就是解决存储和计算的问题  

### 分布式文件系统 ###
* 对于一些图片、大文件的存储，使用数据库就不适合了
* NAS网络存储设备本身的IO吞吐性能及扩展性不高
* 分布式文件系统，主要解决单机文件存储容量及安全性的问题
* 把多台廉价PC组成一个大的分布式的看起来像文件系统的集群，并对外提供文件系统服务，如HDFS，TFS

* 分布式文件系统通常可以作为底层存储
	* 如GFS作为Google bigtable的底层
	* EBS作为 Amazon RDS的底层
	* HDFS作为HBase的底层文件系统
	* HBase可以说是借鉴BigTable的一个Java版本的开源实现

### NoSQL ###
* NoSQL 和 SQL 的基础都来自于Key-Value
* 如果NoSQL继续发展并完善功能，就会变成SQL关系型数据库

* Key-Value
	* 基础的技术支撑，没有办法进行高效的范围查询
* Ordered Key-Value
	* Key是有序的，解决了范围查询的效率问题
* BigTable
	* 是一个结构化数据的分布式数据系统。Value是有多个Column Family组成，Column Family 内部是Column，Column Family不能动态扩展，但Column可以
* Document，Full-Text Search
	* Document 数据库有两大非常大的进步，一个是可以在Value中任意自定义复杂的Scheme，而不再仅仅是Map的嵌套；
	* 另一个是，对索引的支持，而全文索引则提供了对数据内容的搜索的支持
	* 将全文索引归属于NoSQL的范畴有些牵强
* Graph
	
### 缓存系统 ###
使用缓存有俩中模式：  

* 应用不直接操作存储，存储有缓存来控制
	* 需要保证数据写入缓存后能够存入存储中
	* 需要有很多的操作日志及故障恢复等
	* 注意缓存和数据存储中数据的一致性

* 应用直接与缓存和存储进行交互
	* 写数据时更新存储，然后失效缓存数据
	* 读数据时
		* 首先读缓存
		* 如果缓存没命中，读存储，并把数据写入缓存
	* 注意缓存和存储数据一致性问题，最终一致性
	* 以及更新存储后，没来得及失效缓存的问题

#### Web 页面缓存 ####
* 缓存页面静态内容
* 实现技术为ESI
	* 是通过在返回页面中加上特殊的标签
	* 然后根据标签的内容进行去用缓存进行填充的过程

### 搜索系统 ###
#### 爬虫问题 ####
* 通过定时从数据源中拉取数据，来跟新索引
* 通过数据变更的通知，即使通知搜索引擎构建索引

#### 到排序 ####
* 文章 对应 关键字
* 变成 关键字 对应 文章
* 一个关键字对应好多文章
* 搜索引擎就能很好的实现到排序
* 主要是对搜索的内容进行分词

#### 查询与处理 ####
* 主要负责对用户输入的搜索内容进行分词和分词后的分析
* 包括一些同义词替换及纠错
* 这一部分工作的好坏直接影响搜索结果的质量

#### 相关度计算 ####
* 计算搜索内容的相关度展示给用户

#### 数据计算支撑 ####
* 离线计算
	* 将业务产生的数据离开生产环境后进行的计算
	* MapReduce
		* Map:根据设定的规则，把整体数据集映射给不同的Worker来处理，并生成各自的处理结果
		* Reduce：对Map处理过的数据进行聚合，形成最终结果
		* 一个任务可能不止一次MapReduce

	* Hadoop 是 MapReduce 的一个开源实现
		* Hadoop 使用 HDFS 进行数据存储
		* Spark 则提供了基于内存的集群计算支持
* 在线计算
	* 流式计算：Storm